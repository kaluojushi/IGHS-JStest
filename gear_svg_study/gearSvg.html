<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Involute Spur Gear Builder</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="description"
        content="Involute spur gear builder with SVG output. Licensed under the MIT license (http://opensource.org/licenses/mit-license.php). Copyright 2020 Dr. Rainer Hessmer">
  <meta name="author" content="Dr. Rainer Hessmer">
  <style type="text/css">
    body {
      font: 14px/20px 'Helvetica Neue Light', HelveticaNeue-Light, 'Helvetica Neue', Helvetica, Arial, sans-serif;
      max-width: 820px;
      margin: 0 auto;
      padding: 10px;
    }

    textarea {
      font: 12px/20px Monaco, monospace;
      border: 1px solid #CCC;
      border-radius: 3px;
      background: LightGray;
      padding: 10px;
      width: 800px;
    }

    .parametersdiv {
      border: 1px solid black;
      -moz-border-radius: 5px;
      -webkit-border-radius: 5px;
      border-radius: 5px;
      padding: 10px;
    }

    .svgdiv {
      border: 1px solid black;
      padding: 10px;
    }
  </style>

  <script type="text/javascript" src="lib/js/clipper_unminified.js"></script>
  <script type="text/javascript" src="lib/js/svg.js"></script>
  <script type="text/javascript" src="lib/js/svg.path.js"></script>
  <script type="text/javascript" src="lib/js/svg.export.js"></script>
  <script type="text/javascript" src="lib/js/svg.pan-zoom.js"></script>
  <script type="module" src="lib/modules/parameters.js"></script>
  <script type="module" src="lib/modules/status.js"></script>
  <script type="module">
    import {Parameters} from './lib/modules/parameters.js';
    import {StatusCode, Status} from './lib/modules/status.js';

    // Hook up event handlers
    window.addEventListener("load", onLoad);
    document.querySelector('#update').addEventListener('click', update)

    const ORIGIN = {X: 0, Y: 0};  // 原点坐标
    const CLIPPER_SCALE = 100000;
    const CLIPPER_LIGHTEN_FACTOR = 0.0005;

    var drawingWidth; // 画框宽度
    var drawingHeight;  // 画框高度
    var clipper;
    var drawing;  // SVG对象
    var mainGroup;  // SVG主要形状组
    var parameters; // 参数对象

    // 返回齿轮参数定义列表
    function getParameterDefinitions() {
      return [
        {
          name: 'circularPitch',  // 齿距p
          caption: 'Circular pitch (the circumference of the pitch circle divided by the number of teeth):',  // 齿距为分度圆周长除以齿数，p = πd/z = πm
          type: 'float',
          initial: 8
        },
        {
          name: 'pressureAngle',  // 压力角α
          caption: 'Pressure Angle (common values are 14.5, 20 and 25 degrees):',
          type: 'float',
          initial: 20
        },
        {
          name: 'clearance',  // 顶隙c
          caption: 'Clearance (minimal distance between the apex of a tooth and the trough of the other gear; in length units):', // 一齿齿顶与另一齿齿槽间的最小距离
          type: 'float',
          initial: 0.05
        },
        {
          name: 'backlash', // 齿侧间隙
          caption: 'Backlash (minimal distance between meshing gears; in length units):', // 啮合齿轮的最小距离
          type: 'float',
          initial: 0.05
        },
        {
          name: 'profileShift', // 变位系数
          caption: 'Profile Shift (indicates what portion of gear one\'s addendum height should be shifted to gear two. E.g., a value of 0.1 means the adddendum of gear two is increased by a factor of 1.1 while the height of the addendum of gear one is reduced to 0.9 of its normal height):',
          // 这里表示两齿轮啮合时，小齿轮的齿顶高应增加多少倍，大齿轮的齿顶高应减少多少倍
          type: 'float',
          initial: 0.0
        },
        {
          name: 'gear1ToothCount',  // 齿数z
          caption: 'Gear 1 Tooth Count (n1 > 0: external gear; n1 = 0: rack; n1 < 0: internal gear):',
          type: 'int',
          initial: 30
        },
        {name: 'gear1PitchDiameter', caption: 'Gear 1 Pitch Circle Diameter', type: 'float', isCalculated: true}, // 分度圆直径d，d = mz = pz/π
        {name: 'gear1OuterDiameter', caption: 'Gear 1 Outer Circle Diameter', type: 'float', isCalculated: true}, // 外径（齿顶圆直径）da，da = d + 2ha，本例ha*按1计算
        {
          name: 'gear1CenterHoleDiamater',  // 中心孔直径
          caption: 'Gear 1 Center Hole Diameter (0 for no hole):',
          type: 'float',
          initial: 4
        },
        {name: 'gear2ToothCount', caption: 'Gear 2 Tooth Count:', type: 'int', initial: 8},
        {name: 'gear2PitchDiameter', caption: 'Gear 2 Pitch Circle Diameter', type: 'float', isCalculated: true},
        {name: 'gear2OuterDiameter', caption: 'Gear 2 Outer Circle Diameter', type: 'float', isCalculated: true},
        {
          name: 'gear2CenterHoleDiamater',
          caption: 'Gear 2 Center Hole Diameter (0 for no hole):',
          type: 'float',
          initial: 4
        },
        {name: 'gearCentersDistance', caption: 'Gear Centers Distance', type: 'float', isCalculated: true}, // 齿轮中心距a，为分度圆半径之和，a = (d1+d2)/2 = m(z1+z2)/2
        {
          name: 'showOption',
          caption: 'Show:',
          type: 'choice',
          values: [3, 1, 2],
          initial: 3,
          captions: ["Gear 1 and 2", "Gear 1 Only", "Gear 2 Only"]
        },
      ];
    }

    var helperLinesStyle = {  // 辅助线样式
      color: 'blue',
      width: 0.04
    };

    var helperLinesStyle2 = {
      color: 'green',
      width: 0.04
    };

    var markerLinesStyle = {  // 标记线样式
      color: 'red',
      width: 0.04
    };

    var regularLinesStyle = { // 普通线样式
      color: 'black',
      width: 0.1
    };

    var regularLinesStyle2 = {
      color: 'red',
      width: 0.04
    };

    // 窗口加载事件
    function onLoad() {
      let drawingDiv = document.getElementById('drawing');
      drawingWidth = 800;
      drawingHeight = 800;
      drawingDiv.style.width = drawingWidth + 'px';
      drawingDiv.style.height = drawingHeight + 'px';

      let parameterDefinitions = getParameterDefinitions();
      parameters = new Parameters(parameterDefinitions);

      var parametersDiv = document.getElementById("parameters");
      parameters.createParamControls(parametersDiv);
      parameters.updateFromQueryParams();

      drawing = SVG('drawing');

      update();
    }

    // 更新时（当用户更新参数点击按钮时）
    function update() {
      var gearSet = new GearSet();
      parameters.injectFromUI(gearSet);
      let status = gearSet.update();
      if (!status.ok()) {
        alert(status.message);
        return;
      }
      parameters.writeToUI(gearSet);
      parameters.setQueryParameters();

      // 展示齿轮
      display(gearSet);
      // 导出SVG
      exportSvg(gearSet);
    }

    // 展示齿轮
    function display(gearSet) {
      drawing.clear();  // 清空SVG
      let topGroup = drawing.group(); // SVG顶层形状组
      topGroup.panZoom(); // 缩放

      // Scale to fit with some border around
      // 缩放以适应周围的一些边框
      var borderRatio = 0.02; // 边框比率
      var border = borderRatio * Math.max(gearSet.width, gearSet.height); // 齿轮集宽高之外需要预留的边框大小（距离）
      // 上下左右留白
      var totalWidth = gearSet.width + 2 * border;
      var totalHeight = gearSet.height + 2 * border;

      var scalingFactor = Math.min(drawingWidth / totalWidth, drawingHeight / totalHeight); // 图形大小相对于画框大小的缩放倍数
      // SVG的主要形状组
      // 给出缩放倍数、横纵坐标
      mainGroup = topGroup.group().scale(scalingFactor, scalingFactor).x(-gearSet.center.X).y(-gearSet.center.Y);
      // 将原点从左上角改为图形中心
      mainGroup.dx(drawingWidth / scalingFactor / 2);
      mainGroup.dy(drawingHeight / scalingFactor / 2);

      //console.log(drawingWidth / scalingFactor / 2);
      //console.log(gearSet.width / 2);

      // 设定主要形状组使用普通线样式绘画
      mainGroup.stroke(regularLinesStyle).fill('none');

      // 画齿轮
      gearSet.createGraphics(mainGroup);
    }

    function exportSvg(gearSet) {
      // For export we use a separate svg instance that is properly sized in mm.
      // 对于导出，我们使用一个单独的SVG实例，其大小以mm为单位
      // The viewbox is always in px. 1 mm = 3.543307 px (see https://mpetroff.net/2013/08/analysis-of-svg-units/)
      // 视图框始终以px为单位
      let pxPerMillimeter = 3.543307;
      // We leave some space around the escapement drawing.
      // 在图纸周围留了一些空间
      let borderRatio = 0.05;
      let border = borderRatio * Math.max(gearSet.width, gearSet.height);
      let totalWidth = gearSet.width + 2 * border;
      let totalHeight = gearSet.height + 2 * border;
      let drawingForExport = SVG('drawingForExport')
          .size(totalWidth + 'mm', totalHeight + 'mm')
          .viewbox(gearSet.left - border, -gearSet.top - border, totalWidth, totalHeight);
      let topGroup = drawingForExport.group();

      gearSet.createGraphics(topGroup);
      let exportedSVG = drawingForExport.exportSvg({whitespace: true});
      document.getElementById("exportedSVG").value = exportedSVG;

      // based on code from Andreas Köberle (http://stackoverflow.com/questions/10120975/how-to-save-an-svg-generated-by-raphael)
      let anchor = document.getElementById('downloadSVG');
      anchor.innerHTML = 'Download SVG';
      anchor.download = `involute_gear_${gearSet.gear1.toothCount ? gearSet.gear1.toothCount : 0}_to_${gearSet.gear2.toothCount}.svg`;
      anchor.type = 'image/svg+xml';

      // see Eric Bidelman: http://updates.html5rocks.com/2012/06/Don-t-Build-Blobs-Construct-Them
      let blob = new Blob([exportedSVG], {type: 'image/svg+xml'});
      anchor.href = (window.URL || webkitURL).createObjectURL(blob);
    }

    // 齿轮集合类
    class GearSet {
      // 更新齿轮集
      update() {
        // convert circular pitch to diametral pitch
        // 计算齿轮径距，即模数m的倒数
        this.diametralPitch = Math.PI / this.circularPitch;

        // Gear 2 must always be a regular gear.
        if (this.gear2ToothCount < 3) {
          return Status.createError('Gear 2 must have at least three teeth.');
        }
        // 常规齿轮对象
        // 齿轮集、齿数、中心孔直径、顶隙、齿侧间隙、变位
        this.gear2 = new RegularGear(
            this,
            this.gear2ToothCount,
            this.gear2CenterHoleDiamater,
            this.clearance,
            this.backlash,
            this.profileShift
        );
        // 分度圆直径、外径
        this.gear2PitchDiameter = this.gear2.pitchDiameter;
        this.gear2OuterDiameter = 2 * this.gear2.outerRadius;

        if (this.gear1ToothCount == 0) {
          // Create rack
          this.gear1 = new Rack(
              this,
              this.clearance,
              this.backlash,
              -this.profileShift
          );
          this.gear1PitchDiameter = 0;
          this.gear1OuterDiameter = 0;
          this.gearCentersDistance = 0;

          this.gear1.isLeft = true;
          this.gear2.isLeft = false;
        }

        if (this.gear1ToothCount > 0) {
          // Regular gear
          // 常规齿轮
          if (this.gear1ToothCount < 3) {
            return Status.createError('External gear 1 must have at least three teeth.');
          }

          // 齿轮集、齿数、中心孔直径、顶隙、齿侧间隙、变位（齿轮1会变小）
          this.gear1 = new RegularGear(
              this,
              this.gear1ToothCount,
              this.gear1CenterHoleDiamater,
              this.clearance,
              this.backlash,
              -this.profileShift
          );
          // 分度圆直径、外径、齿轮中心距（两分度半径之和）
          this.gear1PitchDiameter = this.gear1.pitchDiameter;
          this.gear1OuterDiameter = 2 * this.gear1.outerRadius;
          this.gearCentersDistance = this.gear1.pitchRadius + this.gear2.pitchRadius;

          // 齿轮是否在左边
          this.gear1.isLeft = true;
          this.gear2.isLeft = false;
        }

        if (this.gear1ToothCount < 0) {
          // Internal gear
          if (-this.gear1ToothCount - this.gear2ToothCount < 1) {
            return Status.createError('Internal gear 1 must have at least one more tooth than gear 2.');
          }

          this.gear1 = new InternalGear(
              this,
              -this.gear1ToothCount,
              this.clearance,
              this.backlash,
              -this.profileShift
          );
          this.gear1PitchDiameter = this.gear1.pitchDiameter;
          this.gear1OuterDiameter = 2 * this.gear1.outerRadius;
          this.gearCentersDistance = this.gear1.pitchRadius - this.gear2.pitchRadius;

          this.gear1.isLeft = false;
          this.gear2.isLeft = true;
        }

        // 连接齿轮
        this.gear1.connectedGear = this.gear2;
        this.gear2.connectedGear = this.gear1;

        this.gear1.center = ORIGIN; // 齿轮1中心为原点
        this.gear2.center = this.calcGear2Center(); // 齿轮2中心坐标

        this.gear1.update();  // 齿轮1更新
        this.gear2.update();  // 齿轮2更新

        // 图形的左上角坐标
        this.topLeft = createPoint(Math.min(this.gear1.topLeft.X, this.gear2.topLeft.X), Math.max(this.gear1.topLeft.Y, this.gear2.topLeft.Y));
        // 图形的右上角坐标
        this.lowerRight = createPoint(Math.max(this.gear1.lowerRight.X, this.gear2.lowerRight.X), Math.min(this.gear1.lowerRight.Y, this.gear2.lowerRight.Y));

        // 图形的宽度、长度、中心坐标
        this.width = this.lowerRight.X - this.topLeft.X;
        this.height = this.topLeft.Y - this.lowerRight.Y;
        this.center = multiplyVector(0.5, addVectors(this.topLeft, this.lowerRight));

        // 图形的左、上坐标
        this.left = this.topLeft.X;
        this.top = this.topLeft.Y;

        return Status.OK;
      }

      // 计算齿轮2的中心坐标
      calcGear2Center() {
        if (this.gear1ToothCount == 0) {
          // Rack
          return addVectors(this.gear1.center, createPoint(this.gear2.pitchRadius, 0));
        }
        if (this.gear1ToothCount > 0) {
          // Regular gear
          return addVectors(this.gear1.center, createPoint(this.gear1.pitchRadius + this.gear2.pitchRadius, 0));
          // 齿轮2的中心是齿轮1的中心向右移动中心距的距离
        }
        if (this.gear1ToothCount < 0) {
          // Inner gear
          return addVectors(this.gear1.center, createPoint(this.gear1.pitchRadius - this.gear2.pitchRadius, 0));
        }
      }

      // 绘画图形（传入父元素）
      createGraphics(parent) {
        // 中心十字标记的长度
        let crossMarkerLength = Math.min(this.circularPitch / 2, this.width / 50);
        if ((this.showOption & 2) > 0) {
          // show gear 2
          // 显示齿轮2
          this.gear2.createGraphics(parent, crossMarkerLength);
        }
        if ((this.showOption & 1) > 0) {
          // show gear 1
          // 显示齿轮1
          this.gear1.createGraphics(parent, crossMarkerLength);
        }
      }
    }

    // 常规齿轮类
    class RegularGear {
      // 齿轮集合对象、齿数、中心孔直径、顶隙、齿侧间隙、变位、齿顶延伸
      constructor(gearSet, toothCount, centerHoleDiameter, clearance, backlash, profileShift, addendumExtension = 0) {
        this.gearSet = gearSet;
        this.toothCount = toothCount;

        this.centerHoleDiameter = centerHoleDiameter;
        this.clearance = clearance;
        this.backlash = backlash;
        this.profileShift = profileShift;

        // addendumExtension is only set for a pinion that is used as a cutter of an inner gear. In this case the
        // addendum extension creates the clearance between the inner gear and its pinion.
        // 齿顶延伸仅用于内齿轮刀具的小齿轮，内齿轮和小齿轮间会产生间隙
        this.addendumExtension = addendumExtension;

        this.angle = 0; // angle in rad of the complete gear (changes during rotation animation)

        // Pitch diameter: Diameter of pitch circle.
        // 分度圆直径：分度圆的直径
        this.pitchDiameter = this.toothCount / this.gearSet.diametralPitch; // 分度圆直径 d = mz
        this.pitchRadius = this.pitchDiameter / 2;  // 分度圆半径r

        // Addendum: Radial distance from pitch circle to outside circle.
        // 齿顶高：分度圆到外圆（齿顶圆）的径向距离
        this.addendum = 1 / this.gearSet.diametralPitch;  // 齿顶高 ha = ha*m，这里ha*按1计算

        // Typically no profile shift is used meaning that this.shiftedAddendum = this.addendum
        // 通常不使用变位系数，即变位齿顶高等于齿顶高
        // 当加工齿数较少的齿轮时，为避免根切，刀具将移离齿坯，产生变位量X，或表示为xm
        // 这样加工的齿轮齿厚s增大，齿顶高ha增大，齿根高hf减小
        // 这里的变位系数x'表示小齿轮的齿顶高应增加多少倍，而非x
        // 根据 ha' = ha(1+x') = ha+xm，x = ha*x'，当ha*为1时，x=x'
        this.shiftedAddendum = this.addendum * (1 + this.profileShift); // 变位齿顶高 ha' = ha(1+x')

        //Outer Circle
        // 外圆（齿顶圆）
        this.outerRadius = this.pitchRadius + this.shiftedAddendum + this.addendumExtension;  // 齿顶圆半径
        this.angleToothToTooth = degreeToRad(360 / this.toothCount);  // 每个齿的圆心角（弧度）
      }

      // 更新齿轮坐标与点集
      update() {
        // 齿轮的左上角坐标是中心向左移动一个外半径、向上移动一个外半径
        this.topLeft = addVectors(createPoint(-this.outerRadius, this.outerRadius), this.center);
        // 齿轮的右下角坐标是中心向右移动一个外半径、向下移动一个外半径
        this.lowerRight = addVectors(createPoint(this.outerRadius, -this.outerRadius), this.center);

        // 齿轮的齿点集模板
        this.toothPointsTemplate = this.createToothPath();
      }

      // 绘画图形（传入父元素和十字标记长度）
      createGraphics(parent, crossMarkerLength) {
        var gearGroup = parent.group(); // 齿轮形状组
        var helperGroup = gearGroup.group();  // 辅助形状组
        // 设定辅助形状组使用辅助线样式绘画
        helperGroup.stroke(helperLinesStyle).fill('none');
        // Pitch circle
        // 画分度圆
        drawCircle(helperGroup, ORIGIN, this.pitchRadius);
        // Outer circle
        // 画外圆（齿顶圆）
        drawCircle(helperGroup, ORIGIN, this.outerRadius);

        // 画十字标记
        drawCross(helperGroup, ORIGIN, crossMarkerLength);

        var regularGroup = gearGroup.group(); // 一般形状组（齿轮）
        // 设定一般形状组使用一般线样式绘画
        regularGroup.stroke(regularLinesStyle).fill('none');

        if (this.centerHoleDiameter > 0) {
          // 画中心孔
          drawCircle(regularGroup, ORIGIN, this.centerHoleDiameter / 2);
        }

        //let {cutterPath, lowerLeftCorner} = this.createToothCutter();
        //insertSvgPath(regularGroup, cutterPath, /* isClosed=*/true);

        //let toothSectorPath = this.createToothSectorPath();
        //insertSvgPath(regularGroup, toothSectorPath, /* isClosed=*/true);

        //let {cutterPaths, lowerLeftCornerIndex} = this.createToothCutterPaths();
        //cutterPaths.forEach(toothCutterPath => insertSvgPath(regularGroup, toothCutterPath, /* isClosed=*/true));

        //let cornersPath = [];
        //cutterPaths.forEach(toothCutterPath => cornersPath.push(clonePoint(toothCutterPath[lowerLeftCornerIndex])));

        //var helperGroup2 = gearGroup.group();
        //helperGroup2.stroke(markerLinesStyle).fill('none');
        //drawCircles(helperGroup2, cornersPath, 0.0001);
        //insertSvgPath(helperGroup2, cornersPath, /* isClosed=*/true)


        //let halfToothPath = this.createHalfToothPath();
        //insertSvgPath(regularGroup, halfToothPath, /* isClosed=*/false);
        //drawCircles(helperGroup, halfToothPath, 0.0002);
        //drawCircle(helperGroup, toothCutoutPath[dedendumStartIndex], 0.1);

        //let toothPath = this.createToothPath();
        //insertSvgPath(regularGroup, toothPath, /* isClosed=*/false);
        //drawCircles(helperGroup, toothPath, 0.01);

        //let nextIndex = (dedendumStartIndex - 1) % toothCutoutPath.length;
        //drawCircle(helperGroup, toothCutoutPath[nextIndex], 0.1);

        //let corners = [];
        //cutterPaths.forEach(toothCutterPath => corners.push(toothCutterPath[lowerLeftCornerIndex]));
        //drawCircles(helperGroup, corners, 0.1);

        this.insertGearSvgPath(regularGroup);

        // 移动齿轮形状组到中心坐标位置
        gearGroup.move(this.center.X, this.center.Y);
      }

      createToothSectorPath() {
        // create outer circle sector covering one tooth
        return [
          ORIGIN,
          createPoint(0, this.outerRadius),
          rotatePointAroundCenter(createPoint(0, this.outerRadius), ORIGIN, this.angleToothToTooth)
        ];
      }

      // 插入齿轮SVG路径
      insertGearSvgPath(group) {
        let svgPath = group.path();
        // 注意在SVG中，y轴正方向为下方，因此笛卡尔坐标系的顺时针旋转相当于SVG坐标系的逆时针旋转
        var firstSvgPoint;
        // Next create N (tooth count) rotated tooth paths and connect them via arcs.
        // 接下来创建N个旋转齿路径，然后通过圆弧连接它们
        var angleOffset;  // 角度偏移

        if (this.isLeft) {
          // rotate counter clockwise so that the starter tooth points east.
          // 逆时针旋转，使起始齿指向东方
          angleOffset = -Math.PI / 2 - this.angleToothToTooth / 2;
        } else {
          // rotate clock wise so that the starter tooth meshes with the left gear.
          // 顺时针旋转，使起始齿与左齿轮啮合
          angleOffset = Math.PI / 2 - this.angleToothToTooth;
        }

        // 画N个齿
        for (let i = 0; i < this.toothCount; i++) {
          // 每个齿的旋转角
          let angle = i * this.angleToothToTooth + angleOffset;
          // 旋转后的齿点集模板
          let rotatedToothPoints = rotatePointsAroundCenter(this.toothPointsTemplate, ORIGIN, angle);

          if (i === 0) {
            // Start with the second point since the closing arc of the last tooth will add the first point.
            // 从第二个点开始，因为最后一个齿的闭合弧将添加第一个点
            // 这一步画了一个齿槽
            addLineSegmentsToPath(svgPath, rotatedToothPoints.slice(1), /*moveToFirst=*/ true);
            firstSvgPoint = createSvgPoint(rotatedToothPoints[0]);
          } else {
            // connect the previous last point with an arc to the new, rotated tooth points.
            // 用圆弧将上一个最后一点连接到新的旋转齿点
            // 这一步画了齿顶圆的一部分，其中前两个参数是半径，0表示不旋转，0表示小弧，1表示顺时针，最后一个参数是终点
            svgPath.A(this.outerRadius, this.outerRadius, 0, 0, 1, createSvgPoint(rotatedToothPoints[0]));
            // 这一步继续画接下来的齿槽
            addLineSegmentsToPath(svgPath, rotatedToothPoints.slice(1));
          }
        }

        // Close the path by connecting the final arc.
        // 通过连接最终圆弧闭合路径
        svgPath.A(this.outerRadius, this.outerRadius, 0, 0, 1, firstSvgPoint);
        // Close the path
        // 闭合路径
        svgPath.Z();

        return svgPath;
      }

      // 创建齿路径
      createToothPath() {
        let halfToothPath = this.createHalfToothPath();

        let toothPath = [];
        // Add mirrored half tooth
        // 添加镜像的半个齿
        for (let i = halfToothPath.length - 1; i > 0; i--) {
          let point = halfToothPath[i];
          toothPath.push(createPoint(-point.X, point.Y));
        }
        // Add the unmirrored original half.
        // 添加未镜像的原始一半
        halfToothPath.forEach(point => toothPath.push(point));

        return toothPath;
      }

      // 创建一半的齿路径
      createHalfToothPath() {
        let toothCutoutPath = this.createToothCutoutPath();

        // Intersect with a slice that is half the pitch angle.
        let angle = this.angleToothToTooth / 2;
        let cosAngle = Math.cos(angle);
        let sinAngle = Math.sin(angle);

        let halfPointOnCircle = {X: -this.outerRadius * sinAngle, Y: this.outerRadius * cosAngle};
        // 切线截距
        let tangentIntercept = {
          X: 0,
          Y: this.outerRadius * (cosAngle + sinAngle * sinAngle / cosAngle)
        };

        let intersectPath = [
          ORIGIN,
          halfPointOnCircle,
          tangentIntercept
        ];
        ClipperLib.JS.ScaleUpPath(intersectPath, CLIPPER_SCALE);

        var clipper = new ClipperLib.Clipper();
        clipper.AddPath(toothCutoutPath, ClipperLib.PolyType.ptSubject, true);  // true means closed path;
        clipper.AddPath(intersectPath, ClipperLib.PolyType.ptClip, true);  // true means closed path;

        let solutionPaths = new ClipperLib.Paths();
        var succeeded = clipper.Execute(ClipperLib.ClipType.ctIntersection, solutionPaths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

        let lightenedPaths = ClipperLib.JS.Lighten(solutionPaths[0], this.gearSet.circularPitch * CLIPPER_LIGHTEN_FACTOR * CLIPPER_SCALE);
        var clippedToothCutoutPath = lightenedPaths[0];

        ClipperLib.JS.ScaleDownPath(clippedToothCutoutPath, CLIPPER_SCALE);

        // Find dedendum start point at x == 0;
        // 在x=0处找到齿根圆起点
        let dedendumStartIndex = clippedToothCutoutPath.findIndex((point) => Math.abs(point.X) < 0.01 * this.addendum && point.Y < this.pitchRadius);
        //console.log("dedendumStartIndex: ", dedendumStartIndex);

        // Start from the dedendumStartIndex and iterate over all points until the next point is outside of the outer radius.
        // 从该点开始，迭代所有点，直到下一个点位于外半径之外
        let halfToothPath = [clippedToothCutoutPath[dedendumStartIndex]];
        var currentIndex = dedendumStartIndex;
        let squaredOuterRadius = this.outerRadius * this.outerRadius;
        let getNextIndex = (index) => (index - 1 + clippedToothCutoutPath.length) % clippedToothCutoutPath.length
        while (true) {
          let nextIndex = getNextIndex(currentIndex);
          if (squaredLenth(clippedToothCutoutPath[nextIndex]) >= squaredOuterRadius) {
            break;
          }
          currentIndex = nextIndex;
          halfToothPath.push(clippedToothCutoutPath[currentIndex]);
        }

        // Interpolate between the last point in the trimmed path and the next point
        // to find the point that intersects with the outer radius.
        // 在修剪路径的最后一点与下一点之间插值，以找到与外半径相交的点
        let lastInsidePoint = clippedToothCutoutPath[currentIndex];
        let lastInsideLength = length(lastInsidePoint);

        let firstOnOrOutsidePoint = clippedToothCutoutPath[getNextIndex(currentIndex)];
        let firstOnOrOutsideLength = length(firstOnOrOutsidePoint);

        let ratio = (this.outerRadius - lastInsideLength) / (firstOnOrOutsideLength - lastInsideLength);

        let vectorBetweenPoints = subtractVectors(firstOnOrOutsidePoint, lastInsidePoint);
        let pointOnOuterRadius = addVectors(lastInsidePoint, multiplyVector(ratio, vectorBetweenPoints));

        halfToothPath.push(pointOnOuterRadius);

        return halfToothPath;
      }

      // 创建齿切割路径
      createToothCutoutPath() {
        let {cutterPaths, lowerLeftCornerIndex} = this.createToothCutterPaths();

        // Also create a path from one of the addendum corners to get smooth undercut curves.
        // 还可以从一个齿顶角创建一条路径，以获得平滑的根切曲线
        let cornersPath = [];
        cutterPaths.forEach(toothCutterPath => cornersPath.push(clonePoint(toothCutterPath[lowerLeftCornerIndex])));
        cornersPath.reverse();

        const combinedPaths = [...cutterPaths];
        combinedPaths.push(cornersPath);

        var clipper = new ClipperLib.Clipper();
        combinedPaths.forEach(path => {
          ClipperLib.JS.ScaleUpPath(path, CLIPPER_SCALE);
          clipper.AddPath(path, ClipperLib.PolyType.ptSubject, true);  // true means closed path; true表示闭合路径
        });

        // Union the shapes of all the tooth cutter paths.
        // 合并所有齿刀路径的形状
        var solutionPaths = new ClipperLib.Paths();
        var succeeded = clipper.Execute(ClipperLib.ClipType.ctUnion, solutionPaths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

        return solutionPaths[0];
      }

      // 创建齿刀路径
      createToothCutterPaths() {
        // 齿刀每一步所旋转的角度
        let angleStepSize = Math.PI / 600;

        let {cutterPath, lowerLeftCornerIndex} = this.createToothCutter();
        let cutterPaths = [cutterPath];

        // To create the tooth profile we move the (virtual) infinite gear and then turn the resulting cutter position back.
        // For illustration see http://lcamtuf.coredump.cx/gcnc/ch6/, section 'Putting it all together'.
        // We continue until the moved tooth cutter's lower left corner is outside of the outer circle of the gear.
        // Going any further will no longer influence the shape of the tooth.
        // 为了创建齿廓，我们创造虚拟的无限大齿轮（齿条），然后旋转生成的刀具位置
        // 我们继续该操作，直到移动的齿刀左下角位于齿轮外圆之外
        // 再继续将不会影响齿的形状
        var stepCounter = 0;
        while (true) {
          // 齿轮与齿条在节圆处线速度相同，当齿轮旋转θ角时，齿条移动距离为 ωr*θ/ω = r*θ
          let angle = stepCounter * angleStepSize;
          let xTranslation = angle * this.pitchRadius;

          // we move in both directions
          // 在每个方向上移动
          // 齿条向右移动，齿轮逆时针转动，相对齿轮，梯形齿刀为水平向右、顺时针转动的叠加运动
          var transformedCutterPath = createTranslatedPath(cutterPath, xTranslation, 0);
          transformedCutterPath = rotatePointsAroundCenter(transformedCutterPath, ORIGIN, angle);

          cutterPaths.push(transformedCutterPath)

          // Rotate in opposite direction. This is required to get the undercuts.
          // 在相反方向上移动，这是获得根切所必须的
          // 让梯形齿刀对称运动一次，否则基圆下面会被卡住
          //console.log("xTranslation: " + xTranslation);
          transformedCutterPath = createTranslatedPath(cutterPath, -xTranslation, 0);
          transformedCutterPath = rotatePointsAroundCenter(transformedCutterPath, ORIGIN, -angle);

          cutterPaths.unshift(transformedCutterPath);

          //var movedLowerLeftCorner = createTranslatedPoint(lowerLeftCorner, xTranslation, 0);
          //movedLowerLeftCorner = rotatePointAroundCenter(movedLowerLeftCorner, ORIGIN, angle);

          if (length(transformedCutterPath[lowerLeftCornerIndex]) > this.outerRadius) {
            // The cutter is now completely outside the gear and additional steps will no longer influences the shape of the gear tooth.
            // 刀具现在完全位于齿轮外部，额外的步骤将不再影响轮齿的形状。
            break;
          }

          stepCounter++;
        }

        return {
          cutterPaths: cutterPaths,
          lowerLeftCornerIndex: lowerLeftCornerIndex
        }
      }

      // 创建齿刀
      createToothCutter() {
        // we create a trapezoidal cutter as described at http://lcamtuf.coredump.cx/gcnc/ch6/ under the section 'Putting it all together'
        // 创建一个梯形齿刀
        // 齿厚和齿槽宽都是齿距的一半
        let toothWidth = this.gearSet.circularPitch / 2;
        //console.log("toothWidth: " + toothWidth);
        //console.log("addendum: " + this.addendum);
        //console.log("shiftedAddendum: " + this.shiftedAddendum);
        //console.log("clearance: " + this.clearance);

        // 切削深度，即齿根高，hf = ha + c
        // 齿刀外部长度，定义为3倍的齿根高
        let cutterDepth = this.addendum + this.clearance;
        let cutterOutsideLength = 3 * this.addendum;
        //console.log("cutterDepth: " + cutterDepth);
        //console.log("cutterOutsideLength: " + cutterOutsideLength);

        // 压力角的余弦值和正切值
        let cosPressureAngle = Math.cos(this.gearSet.pressureAngle * Math.PI / 180);
        let tanPressureAngle = Math.tan(this.gearSet.pressureAngle * Math.PI / 180);

        // If a positive backlash is defined then we widen the trapezoid accordingly.
        // Each side of the tooth needs to widened by a fourth of the backlash (perpendicular to the cutter faces).
        // 如果定义了正的齿侧间隙，梯形应被相应地加宽
        // 齿的每一侧需要加宽四分之一的齿侧间隙（垂直于刀面方向）
        let dx = this.backlash / 4 / cosPressureAngle;

        // Create the cutout at 6 o'clock position pointing upwards
        // 在6点钟方向向上创建切口
        // 计算两个y坐标，注意y轴正方向在SVG是6点钟方向
        let yBottom = this.pitchRadius + this.profileShift * this.addendum - cutterDepth;
        let yTop = this.pitchRadius + this.profileShift * this.addendum + cutterOutsideLength;

        // 梯形齿刀四个角的坐标
        let lowerRightCorner = createPoint(toothWidth / 2 + dx - tanPressureAngle * cutterDepth, yBottom);
        let upperRightCorner = createPoint(toothWidth / 2 + dx + tanPressureAngle * cutterOutsideLength, yTop);
        let upperLeftCorner = createPoint(-upperRightCorner.X, upperRightCorner.Y);
        let lowerLeftCorner = createPoint(-lowerRightCorner.X, lowerRightCorner.Y);

        // 梯形齿刀路径（左下角在SVG中为左上角）
        let cutterPath = [lowerLeftCorner, upperLeftCorner, upperRightCorner, lowerRightCorner];

        return {
          cutterPath: cutterPath,
          lowerLeftCornerIndex: 0
        }
      }
    }

    class InternalGear {
      constructor(gearSet, toothCount, clearance, backlash, profileShift) {
        this.gearSet = gearSet;
        this.toothCount = toothCount;
        this.clearance = clearance;
        this.backlash = backlash;
        this.profileShift = profileShift;

        this.angle = 0; // angle in rad of the complete gear (changes during rotation animation)

        // Pitch diameter: Diameter of pitch circle.
        this.pitchDiameter = this.toothCount / this.gearSet.diametralPitch;
        this.pitchRadius = this.pitchDiameter / 2;

        // Addendum: Radial distance from pitch circle to inside circle.
        this.addendum = 1 / this.gearSet.diametralPitch;

        // Typically no profile shift is used meaning that this.shiftedAddendum = this.addendum
        this.shiftedAddendum = this.addendum * (1 + this.profileShift);

        // Inner Circle (addendum)
        this.innerRadius = this.pitchRadius - this.shiftedAddendum;

        // Dedendum Circle
        this.dedendumRadius = this.pitchRadius + this.shiftedAddendum;

        this.angleToothToTooth = degreeToRad(360 / this.toothCount);

        // Outer circle; just a circle that is greater than the dedendum circle.
        this.outerRadius = this.pitchRadius + 2.5 * this.addendum;
      }

      update() {
        this.topLeft = addVectors(createPoint(-this.outerRadius, this.outerRadius), this.center);
        this.lowerRight = addVectors(createPoint(this.outerRadius, -this.outerRadius), this.center);

        this.pinion = this.connectedGear;
        this.toothPointsTemplate = this.createToothPath();
      }

      createGraphics(parent, crossMarkerLength) {
        let gearGroup = parent.group();
        let helperGroup = gearGroup.group();
        helperGroup.stroke(helperLinesStyle).fill('none');
        // Inner circle (addendum)
        drawCircle(helperGroup, ORIGIN, this.innerRadius);
        // Pitch circle
        drawCircle(helperGroup, ORIGIN, this.pitchRadius);
        // Dedendum circle
        drawCircle(helperGroup, ORIGIN, this.dedendumRadius);

        drawCross(helperGroup, ORIGIN, crossMarkerLength);

        //let zeroedHalfCutterPath = this.createZeroedHalfToothCutterPath();
        //insertSvgPath(helperGroup, zeroedHalfCutterPath, true);

        //let halfToothSectorPath = this.createHalfToothSectorPath();
        //insertSvgPath(helperGroup, halfToothSectorPath, /* isClosed=*/true);

        let regularGroup = gearGroup.group();
        regularGroup.stroke(regularLinesStyle).fill('none');

        //let halfToothPath = this.createEnlargedPinionHalfToothPath();
        //insertSvgPath(regularGroup, halfToothPath, /* isClosed=*/false);

        //let zeroedCutterPath = this.createZeroedCutterPath();
        //insertSvgPath(regularGroup, zeroedCutterPath, false);

        let helperGroup2 = gearGroup.group();
        helperGroup2.stroke(helperLinesStyle2).fill('none');

        //let zeroedHalfCutterPath = this.createZeroedHalfToothCutterPath();
        //insertSvgPath(helperGroup2, zeroedHalfCutterPath, true);

        //let halfToothSectorPath = this.createHalfToothSectorPath();
        //insertSvgPath(helperGroup2, halfToothSectorPath, true);

        //let cutterPaths = this.createHalfToothCutterPaths(zeroedHalfCutterPath);
        //cutterPaths.forEach(path => insertSvgPath(helperGroup2, path, true));

        //let cornersPaths = this.createCornersPaths(cutterPaths);
        //cornersPaths.forEach(path => insertSvgPath(helperGroup, path, true));

        let markerGroup = gearGroup.group();
        markerGroup.stroke(markerLinesStyle).fill('none');

        /*
        cornersPaths.forEach(path => {
          drawCircle(markerGroup, path[0], 0.01);
          drawCircle(markerGroup, path.slice(-1)[0], 0.01);
        });
        cornersPaths[0].slice(0,5).forEach(point => {
          drawCircle(markerGroup, point, 0.01);
        });
        */

        //let edgesPath = this.createEdgesPath(cutterPaths);
        //insertSvgPath(markerGroup, edgesPath, true);
        //drawCircles(markerGroup, edgesPath, 0.02);

        //let halfToothPath = this.createHalfToothPath();
        //insertSvgPath(markerGroup, halfToothPath, false);
        //drawCircle(markerGroup, halfToothPath[0], 0.01);
        //drawCircle(markerGroup, halfToothPath.slice(-1)[0], 0.01);

        //let toothPath = this.createToothPath();
        //insertSvgPath(markerGroup, this.toothPointsTemplate, false);

        this.insertGearSvgPath(regularGroup);

        // Outer circle
        drawCircle(regularGroup, ORIGIN, this.outerRadius);

        gearGroup.move(this.center.X, this.center.Y);
      }

      insertGearSvgPath(group) {
        let svgPath = group.path();

        let firstSvgPoint;
        var angleOffset;
        if (this.isLeft) {
          // rotate counter clockwise so that the starter tooth points east.
          angleOffset = Math.PI - this.angleToothToTooth / 2;
        } else {
          // rotate clock wise so that the starter tooth meshes with the left gear.
          angleOffset = -this.angleToothToTooth / 2;
        }
        for (let i = 0; i < this.toothCount; i++) {
          let angle = -i * this.angleToothToTooth + angleOffset;
          let rotatedToothPoints = rotatePointsAroundCenter(this.toothPointsTemplate, ORIGIN, angle);

          if (i == 0) {
            // Start with the second point since the closing arc of the last tooth will add the first point.
            addLineSegmentsToPath(svgPath, rotatedToothPoints.slice(1), /*moveToFirst=*/ true);
            firstSvgPoint = createSvgPoint(rotatedToothPoints[0]);
          } else {
            // connect the previous last point with an arc to the new, rotated tooth points.
            svgPath.A(this.outerRadius, this.outerRadius, 0, 0, 1, createSvgPoint(rotatedToothPoints[0]));
            addLineSegmentsToPath(svgPath, rotatedToothPoints.slice(1));
          }
        }

        // Close the path by connecting the final arc.
        svgPath.A(this.outerRadius, this.outerRadius, 0, 0, 1, firstSvgPoint);
        // Close the path
        svgPath.Z();

        return svgPath;
      }

      createHalfToothSectorPath() {
        // create outer circle sector covering half a tooth
        return [
          ORIGIN,
          createPoint(this.outerRadius, 0),
          rotatePointAroundCenter(createPoint(this.outerRadius, 0), ORIGIN, -this.angleToothToTooth / 2)
        ];
      }

      createCornersPaths(cutterPaths) {
        // Create a paths from each of the corners to avoid ragged edges.
        let cornersPaths = [];
        // Ignore the last point which is always the origin.
        for (let i = 0; i < cutterPaths[0].length - 1; i++) {
          let cornersPath = [];
          cutterPaths.forEach(cutterPath => cornersPath.push(clonePoint(cutterPath[i])));
          cornersPaths.push(cornersPath);
        }

        return cornersPaths;
      }

      createEdgesPath(cutterPaths) {
        // This step is described in the accompanying pdf doc.
        // Conceptually, first we create shapes by connecting correponding points from the various cutter paths.
        // Then we connect the top most endpoints of these shapes.
        // Finally we add the top half of the rightmost shape.

        // Create a paths from each of the corners to avoid ragged edges.
        let edgesPath = [ORIGIN];
        // Ignore the last point which is always the origin.
        for (let i = cutterPaths[0].length - 1; i > 0; i--) {
          let endPoint1 = cutterPaths[0][i];
          let endPoint2 = cutterPaths.slice(-1)[0][i];

          if (endPoint1.Y < endPoint2.Y) {
            edgesPath.push(clonePoint(endPoint1));
          } else {
            edgesPath.push(clonePoint(endPoint2));
          }
        }

        // Add the top half of the points of the rightmost shape.
        for (let i = 0; i < (cutterPaths.length + 1) / 2; i++) {
          edgesPath.push(clonePoint(cutterPaths[i][0]));
        }

        return edgesPath;
      }

      createToothPath() {
        let halfToothPath = this.createHalfToothPath();
        let rotatedHalfToothPath = rotatePointsAroundCenter(halfToothPath, ORIGIN, this.angleToothToTooth / 2);

        let toothPath = [...rotatedHalfToothPath];
        // Add mirrored half tooth
        for (let i = rotatedHalfToothPath.length - 1; i > 0; i--) {
          let point = rotatedHalfToothPath[i];
          toothPath.push(createPoint(point.X, -point.Y));
        }

        return toothPath;
      }

      createHalfToothPath() {
        let zeroedHalfCutterPath = this.createZeroedHalfToothCutterPath();
        let cutterPaths = this.createHalfToothCutterPaths(zeroedHalfCutterPath);
        // Also create a paths from each of the corners to avoid ragged edges.
        let cornersPaths = this.createCornersPaths(cutterPaths);
        let edgesPath = this.createEdgesPath(cutterPaths);
        let halfToothSectorPath = this.createHalfToothSectorPath();

        // Scale them all up to prepare for union and interesction operations.
        cutterPaths.forEach(path => {
          ClipperLib.JS.ScaleUpPath(path, CLIPPER_SCALE);
        });
        cornersPaths.forEach(path => {
          ClipperLib.JS.ScaleUpPath(path, CLIPPER_SCALE);
        });
        ClipperLib.JS.ScaleUpPath(edgesPath, CLIPPER_SCALE);
        // The edges path often self intersects. If needed split into non-intersecting paths.
        let nonIntersectingEdgesPaths = ClipperLib.Clipper.SimplifyPolygon(edgesPath, ClipperLib.PolyFillType.pftNonZero);
        ClipperLib.JS.ScaleUpPath(halfToothSectorPath, CLIPPER_SCALE);

        // Union all these shapes then clip with the half tooth sector path.
        let cutoutFromAllPaths = this.unionAndClipPaths([...cutterPaths, ...cornersPaths, ...nonIntersectingEdgesPaths], halfToothSectorPath);

        // Remove the origin and order the points so that the point intersecting with the addendum is the first point.
        var indexOfOrigin;
        for (let i = 0; i < cutoutFromAllPaths.length; i++) {
          let point = cutoutFromAllPaths[i];
          if (point.X == 0 && point.Y == 0) {
            indexOfOrigin = i;
            break;
          }
        }
        console.log(`Index of origin: ${indexOfOrigin}`);
        let maxSquaredRadius = 0;
        let indexMaxSquaredRadius = 0;
        let halfToothPath = [];
        for (let i = 1; i < cutoutFromAllPaths.length; i++) {
          let point = cutoutFromAllPaths[(indexOfOrigin + i) % cutoutFromAllPaths.length];
          let squaredRadius = squaredLenth(point);
          if (squaredRadius > maxSquaredRadius) {
            maxSquaredRadius = squaredRadius;
            indexMaxSquaredRadius = i - 1;
          }
          halfToothPath.push(point);
        }
        console.log(`Index of max radius point: ${indexMaxSquaredRadius}`);

        // Shave off the part beyond the max radius point.
        halfToothPath = halfToothPath.slice(0, indexMaxSquaredRadius + 1);

        let lightenedPaths = ClipperLib.JS.Lighten(halfToothPath, this.gearSet.circularPitch * CLIPPER_LIGHTEN_FACTOR * CLIPPER_SCALE);
        let lightenedHalfToothPath = lightenedPaths[0];
        console.log(`Length of lightened half tooth path: ${lightenedHalfToothPath.length}`);

        ClipperLib.JS.ScaleDownPath(lightenedHalfToothPath, CLIPPER_SCALE);
        return lightenedHalfToothPath.reverse();
      }

      unionAndClipPaths(scaledUpPaths, scaledUpHalfToothSectorPath) {
        let orientation = ClipperLib.Clipper.Orientation(scaledUpHalfToothSectorPath);

        let clipper = new ClipperLib.Clipper();
        scaledUpPaths.forEach(path => {
          // Make sure the orientation matches.
          if (ClipperLib.Clipper.Orientation(path) != orientation) {
            path.reverse();
          }
          clipper.AddPath(path, ClipperLib.PolyType.ptSubject, true);  // true means closed path;
        });

        // Union the shapes of all paths.
        let solutionPaths = new ClipperLib.Paths();
        let succeeded = clipper.Execute(ClipperLib.ClipType.ctUnion, solutionPaths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

        clipper = new ClipperLib.Clipper();
        clipper.AddPath(scaledUpHalfToothSectorPath, ClipperLib.PolyType.ptSubject, true);  // true means closed path;
        clipper.AddPath(solutionPaths[0], ClipperLib.PolyType.ptClip, true);  // true means closed path;

        solutionPaths = new ClipperLib.Paths();
        succeeded = clipper.Execute(ClipperLib.ClipType.ctIntersection, solutionPaths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
        return solutionPaths[0];
      }

      createHalfToothCutterPaths(zeroedHalfCutterPath) {
        let gearRatio = this.toothCount / this.pinion.toothCount;

        // To create the tooth profile we move the (virtual) infinite gear and then turn the resulting cutter position back.
        // For illustration see http://lcamtuf.coredump.cx/gcnc/ch6/, section 'Putting it all together'.
        // We continue until the moved tooth cutter's lower left corner is outside of the outer circle of the gear.
        // Going any further will no longer influence the shape of the tooth.
        let angleStepSize = this.angleToothToTooth / 10;
        //var angleStepSize = Math.PI / Math.sqrt(this.toothCount - this.pinion.toothCount) / halfCount;
        let cutterPaths = [];

        let pinionRotationAngle = 0;
        let rotatedCutter = this.createRotatedCutter(zeroedHalfCutterPath, pinionRotationAngle, gearRatio);

        cutterPaths.push(rotatedCutter);

        let desiredSquaredDistance = (this.gearSet.circularPitch / 25) ** 2;

        // Empirical value for when a half tooth is covered.
        let maxPinionRotationAngle = 5 * Math.PI / Math.sqrt(this.toothCount - this.pinion.toothCount);

        let cutterEndpointIndex = zeroedHalfCutterPath.length - 1;
        let outerCounter = 0;
        while (outerCounter < 200 && pinionRotationAngle < maxPinionRotationAngle) {
          let previousRotatedCutter = rotatedCutter;
          let previousPinionRotationAngle = pinionRotationAngle;
          //console.log(`Outer counter ${outerCounter}; pinionRotationAngle: ${pinionRotationAngle}; maxPinionRotationAngle: ${maxPinionRotationAngle}`);
          outerCounter++;

          let searchingUp = true;
          let innerCounter = 0;
          while (innerCounter < 20) {
            //console.log(`  inner counter ${innerCounter}`);
            innerCounter++;
            pinionRotationAngle = previousPinionRotationAngle + angleStepSize;
            rotatedCutter = this.createRotatedCutter(zeroedHalfCutterPath, pinionRotationAngle, gearRatio);

            // We look at the start and end point of each cutter path. We dtermine rotation angles so that the squared distance between
            // consecutive start and end points is below an accuracy threshold.
            let squaredDistanceStartPoint = squaredDistance(previousRotatedCutter[0], rotatedCutter[0]);
            let squaredDistanceEndPoint = squaredDistance(previousRotatedCutter[cutterEndpointIndex], rotatedCutter[cutterEndpointIndex]);
            let actualSquaredDistance = Math.max(squaredDistanceStartPoint, squaredDistanceEndPoint);
            if (actualSquaredDistance < desiredSquaredDistance / 10) {
              if (!searchingUp) {
                // We crossed from too big an angle to one that is small enough.
                break;
              } else {
                angleStepSize = 2 * angleStepSize;
              }
            } else if (squaredDistance < desiredSquaredDistance) {
              // new angle is okay
              break;
            } else {
              // squared distance is too large
              searchingUp = false;
              angleStepSize = 0.5 * angleStepSize;
            }
          }
          cutterPaths.push(rotatedCutter);
          cutterPaths.unshift(this.createRotatedCutter(zeroedHalfCutterPath, -pinionRotationAngle, gearRatio));
        }

        console.log(`Cutter paths count: ${cutterPaths.length}`);
        return cutterPaths;
      }

      createRotatedCutter(zeroedHalfCutterPath, pinionRotationAngle, gearRatio) {
        // Rotating the pinion by an angle will also roll it along the inner side of the outer ring gear.
        // First rotate the pinion.
        // This results in the center of the pinion to be rotated around the center of the ring gear.
        let pinionCenterRayAngle = -pinionRotationAngle / gearRatio;

        let transformedCutterPath = rotatePointsAroundCenter(zeroedHalfCutterPath, ORIGIN, pinionCenterRayAngle);
        let rotatedPinionCenter = rotatePointAroundCenter(this.pinion.center, ORIGIN, pinionCenterRayAngle);

        // The pinion turns into the opposite direction.
        let rotatedCutter = rotatePointsAroundCenter(transformedCutterPath, rotatedPinionCenter, pinionRotationAngle);
        // Close the half tooth profile.
        rotatedCutter.push(ORIGIN);
        return rotatedCutter;
      }

      createZeroedHalfToothCutterPath() {
        let enlargedPinionHalfToothPath = this.createEnlargedPinionHalfToothPath();

        // Rotate so that the half tooth points to 3 o'clock. Then shift so that it mashes with the internal gear.
        let rotatedHalfToothPath = rotatePointsAroundCenter(enlargedPinionHalfToothPath, ORIGIN, -Math.PI / 2 - this.pinion.angleToothToTooth / 2);
        return createTranslatedPath(rotatedHalfToothPath, this.pinion.center.X, 0).reverse();
      }

      createEnlargedPinionHalfToothPath() {
        // To cut the internal gear teeth, the actual pinion comes close but we need to enlarge it to properly cater for clearance and backlash
        let enlargedPinion = new RegularGear(
            this.gearSet,
            this.pinion.toothCount,
            /* centerHoleDiameter = */ 0,
            /* clearance = */ 0,
            -this.pinion.backlash,
            this.pinion.profileShift,
            /* addendumExtension = */ this.pinion.clearance
        );

        return enlargedPinion.createHalfToothPath();
        //return enlargedPinion.createToothPath();
      }
    }

    class Rack {
      constructor(gearSet, clearance, backlash, profileShift) {
        this.gearSet = gearSet;
        this.clearance = clearance;
        this.backlash = backlash;
        this.profileShift = profileShift;

        this.addendum = 1 / this.gearSet.diametralPitch;
      }

      update() {
        this.rackShape = this.createRackShape();

        let minX = this.rackShape[this.rackShape.length - 1].X;
        let maxX = this.rackShape[1].X;
        this.topLeft = addVectors(createPoint(minX, this.gearSet.diametralPitch / 2), this.center);
        this.lowerRight = addVectors(createPoint(maxX, -this.gearSet.diametralPitch / 2), this.center);
      }

      createRackShape() {
        let rackToothTemplate = this.createRackTooth();

        // The template is a tooth pointing right and centered on the x-axis.
        // We build the rack by starting with the template and then create an equal number
        // of teeth above and below.

        let rackShape = [];
        let halfCount = Math.floor(this.connectedGear.outerRadius / this.gearSet.circularPitch);
        for (let i = -halfCount; i < halfCount + 1; i++) {
          rackToothTemplate.forEach(point => {
            let deltaY = -i * this.gearSet.circularPitch;
            rackShape.push(createTranslatedPoint(point, 0, deltaY));
          });
        }

        // create a bar backing the teeth.
        let width = 0.5 * this.gearSet.circularPitch;
        let lowerLeftBacking = createTranslatedPoint(rackShape[rackShape.length - 1], -width, 0);
        let upperLeftBacking = createTranslatedPoint(rackShape[0], -width, 0);
        rackShape.push(lowerLeftBacking);
        rackShape.push(upperLeftBacking);

        return rackShape;
        //return rackToothTemplate;
      }

      createRackTooth() {
        // we create a trapezoidal cutter as described at http://lcamtuf.coredump.cx/gcnc/ch6/ under the section 'Putting it all together'
        let toothWidth = this.gearSet.circularPitch / 2;

        //console.log("toothWidth: " + toothWidth);
        //console.log("addendum: " + this.addendum);
        //console.log("shiftedAddendum: " + this.shiftedAddendum);
        //console.log("clearance: " + this.clearance);

        let toothDepth = this.addendum + this.clearance;
        //console.log("toothDepth: " + toothDepth);

        let cosPressureAngle = Math.cos(this.gearSet.pressureAngle * Math.PI / 180);
        let tanPressureAngle = Math.tan(this.gearSet.pressureAngle * Math.PI / 180);

        // If a positive backlash is defined then we narrow the trapezoid accordingly.
        // Each side of the tooth needs to narrowed by a fourth of the backlash (perpendicular to the tooth faces).
        let dx = this.backlash / 4 / cosPressureAngle;
        console.log("backlash: " + this.backlash);
        console.log("dx: " + dx);
        console.log("profileShift: " + this.profileShift);

        // Create the tooth pointing right.
        let profileShiftOffset = this.profileShift * this.addendum;

        let upperLeftCorner = createPoint(-toothDepth + profileShiftOffset, toothWidth / 2 - dx + tanPressureAngle * toothDepth);
        let upperRightCorner = createPoint(this.addendum + profileShiftOffset, toothWidth / 2 - dx - tanPressureAngle * this.addendum);
        let lowerRightCorner = createPoint(upperRightCorner.X, -upperRightCorner.Y);
        let lowerLeftCorner = createPoint(upperLeftCorner.X, -upperLeftCorner.Y);

        return [upperLeftCorner, upperRightCorner, lowerRightCorner, lowerLeftCorner];
      }

      createGraphics(parent, crossMarkerLength) {
        var gearGroup = parent.group();
        var helperGroup = gearGroup.group();
        helperGroup.stroke(helperLinesStyle).fill('none');

        // Draw pitch 'line'.
        helperGroup.line(this.center.X, 2 * this.gearSet.circularPitch, this.center.X, -2 * this.gearSet.circularPitch);

        var regularGroup = gearGroup.group();
        regularGroup.stroke(regularLinesStyle).fill('none');

        insertSvgPath(regularGroup, this.rackShape, /*isClosed=*/ true);

        gearGroup.move(this.center.X, this.center.Y);
      }
    }

    // 点对象
    function createPoint(x, y) {
      return {X: x, Y: y};
    }

    // 克隆一个新点
    function clonePoint(point) {
      return {X: point.X, Y: point.Y};
    }

    // 点的平移
    function createTranslatedPoint(point, dx, dy) {
      return {X: point.X + dx, Y: point.Y + dy};
    }

    // 路径的平移（路径中的每个点平移）
    function createTranslatedPath(path, dx, dy) {
      return path.map(point => createTranslatedPoint(point, dx, dy));
    }

    // Translate point p by vector v
    // 点向向量方向平移
    function translatePoint(p, v) {
      return {X: p.X + v.X, Y: p.Y + v.Y};
    }

    // 点集向向量方向平移（点集中的每个点平移）
    function translatePoints(points, v) {
      return points.map(point => translatePoint(point, v));
    }

    // Squared distance between two 2d points.
    // 两点距离的平方
    function squaredDistance(a, b) {
      return square(a.X - b.X) + square(a.Y - b.Y);
    }

    // Distance between two 2d points.
    // 两点距离
    function distance(a, b) {
      return Math.sqrt(squaredDistance(a, b));
    }

    // 向量长度的平方
    function squaredLenth(vector) {
      return square(vector.X) + square(vector.Y)
    }

    // 向量长度
    function length(vector) {
      return Math.sqrt(squaredLenth(vector));
    }

    // 平方
    function square(x) {
      return x * x
    }

    // 向量之和
    function addVectors(v1, v2) {
      return {X: v1.X + v2.X, Y: v1.Y + v2.Y};
    }

    // 向量之差
    function subtractVectors(v1, v2) {
      return {X: v1.X - v2.X, Y: v1.Y - v2.Y};
    }

    // 向量的数乘
    function multiplyVector(a, v) {
      return {X: a * v.X, Y: a * v.Y};
    }

    // 弧度转角度
    function radToDegree(angle) {
      return angle / Math.PI * 180;
    }

    // 角度转弧度
    function degreeToRad(angle) {
      return angle * Math.PI / 180;
    }

    // 将点旋转一个角度
    function rotatePointAroundCenter(point, center, angle) {
      var cosAngle = Math.cos(angle);
      var sinAngle = Math.sin(angle);
      return _rotatePointAroundCenter(point, center, cosAngle, sinAngle);
    }

    function _rotatePointAroundCenter(point, center, cosAngle, sinAngle) {
      // Move so that center ends up at the origin
      // 移动点，使得中心点落在原点
      var movedPoint = {X: point.X - center.X, Y: point.Y - center.Y};
      var rotated = {
        X: movedPoint.X * cosAngle - movedPoint.Y * sinAngle,
        Y: movedPoint.X * sinAngle + movedPoint.Y * cosAngle,
      };
      // Undo the move
      // 还原移动
      return {X: rotated.X + center.X, Y: rotated.Y + center.Y};
    }

    function rotatePointsAroundCenter(points, center, angle) {
      var cosAngle = Math.cos(angle);
      var sinAngle = Math.sin(angle);

      return points.map(point => _rotatePointAroundCenter(point, center, cosAngle, sinAngle));
    }

    function drawCircles(parent, points, radius) {
      points.forEach(point => drawCircle(parent, point, radius));
    }

    // 画圆，传入父元素、圆心坐标、半径、画笔样式
    function drawCircle(parent, point, radius, strokeStyle) {
      parent.circle(2 * radius).cx(point.X).cy(point.Y);
    }

    function drawCrosses(parent, points, length) {
      points.forEach(point => drawCross(parent, point, length));
    }

    // 画十字标记，传入父元素、中心点、长度
    function drawCross(parent, point, length) {
      let halfLength = length / 2;
      parent.line(point.X, point.Y - halfLength, point.X, point.Y + halfLength); //.stroke(markerLinesStyle);
      parent.line(point.X - halfLength, point.Y, point.X + halfLength, point.Y); // .stroke(markerLinesStyle);
    }

    function createSvgPoint(point) {
      return {x: point.X, y: point.Y};
    }

    // Converts array of {X:..., Y:...} points into an SVG paths.
    function insertSvgPath(group, points, isClosed = true) {
      var svgPath = group.path();
      for (let i = 0; i < points.length; i++) {
        var svgPoint = createSvgPoint(points[i]);
        if (i == 0) {
          svgPath.M(svgPoint);
        } else {
          svgPath.L(svgPoint);
        }
      }
      if (isClosed) {
        svgPath.Z();
      }
    }

    // 将线段添加到SVG路径
    function addLineSegmentsToPath(svgPath, points, moveToFirst = false) {
      for (let i = 0; i < points.length; i++) {
        var svgPoint = createSvgPoint(points[i]);
        if (i == 0 && moveToFirst) {
          svgPath.M(svgPoint);
        } else {
          svgPath.L(svgPoint);
        }
      }
    }
  </script>
</head>

<body>
<h1>Involute Spur Gear Builder v2.0<span style="font-size:10px"> (C) 2020 Dr. Rainer Hessmer</span></h1>
<p>An open source, browser based utility for calculating and drawing involute spur gears. As an improvement over the
  majority of other freely available scripts and utilities it fully accounts for undercuts. For additional information
  please head over to my <a href="http://www.hessmer.org/blog/2020/09/27/online-involute-spur-gear-builder-v2/">blog
    post</a>.</p>
<p>The page runs in modern browsers with SVG support (if in doubt, use <a href="https://www.google.com/chrome/browser">Chrome</a>).
  The generated SVG drawing can be downloaded and imported in CAD applications or opened in the open source SVG editor
  <a href="http://www.inkscape.org/">Inkscape</a> to export as dxf or other formats.</p>
<p>The implementation is inspired by the subtractive process that Michal Zalewski's describes in <a
    href="http://lcamtuf.coredump.cx/gcnc/ch6/#6.2">part six</a> of his excellent <a
    href=" http://lcamtuf.coredump.cx/gcnc/">Guerrilla guide to CNC machining, mold making, and resin casting</a>.</p>
<h2>Instructions</h2>
<p>Specify desired values in the parameters box and then click on the 'Update' button. The tooth count n1 of gear one
  defines various configurations:
<ul>
  <li>n1 &gt; 0: A regular external gear <br><img src="RegularSpurGear_Small.png" alt="Regular Spur Gear"></li>
  <li>n1 = 0: Rack and pinion <br><img src="RackAndPinion_Small.png" alt="Rack and Pinion"></li>
  <li>n1 &lt; 0: An internal gear as used in planetary gears <br><img src="InternalGear_Small.png" alt="Internal Gear">
  </li>
</ul>
</p>
<p>The tool also supports profile shift to reduce the amount of undercut in gears with low tooth counts.
<p>Once the gears are rendered you can use the mouse scroll wheel or the slider underneath the window to zoom in and
  out. For panning move the mouse while pressing the left mouse button.</p>
<div id="parametersblock" class="parametersdiv">
  <b>Parameters</b> (svg output assumes inputs in millimeters)
  <div id="parameters"></div>
  <input id="update" type="button" value="update"/>
</div>
<p>
<div id="drawing" class="svgdiv"></div>
</p>
<p><a id="downloadSVG">place holder</a></p>
<div id="drawingForExport" style="display: none"></div>
<p><textarea id="exportedSVG" rows="2"></textarea></p>

<h2>License and Credits</h2>
<ul>
  <li>The application itself, as well as the application specific source code is copyright (c) 2020 by Dr. Rainer
    Hessmer and is covered by the permissive MIT license.
  </li>
  <li>This page leverages <a href="http://svgjs.com/">svg.js</a> with plug-ins <a
      href="https://github.com/wout/svg.export.js">svg.export.js</a>, <a href="https://github.com/otm/svg.path.js">svg.path.js</a>,
    <a href="http://jillix.github.io/svg.pan-zoom.js/">svg.pan-zoom.js</a>.
  </li>
  <li>For boolean 2d operations <a href="http://jsclipper.sourceforge.net/">Javascript Clipper</a> is used.</li>
</ul>
</body>
</html>